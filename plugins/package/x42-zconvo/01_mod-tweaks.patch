diff --git a/Makefile b/Makefile
index 8695a9a..52f261a 100644
--- a/Makefile
+++ b/Makefile
@@ -72,7 +72,7 @@ endif
 
 # add library dependent flags and libs
 
-override CXXFLAGS +=`$(PKG_CONFIG) --cflags glib-2.0 lv2 sndfile samplerate`
+override CXXFLAGS +=`$(PKG_CONFIG) --cflags lv2 sndfile samplerate`
 override LOADLIBES +=`$(PKG_CONFIG) --libs sndfile samplerate fftw3f` -lm
 
 ifeq ($(shell $(PKG_CONFIG) --atleast-version=1.8.1 lv2 && echo yes), yes)
diff --git a/src/lv2.cc b/src/lv2.cc
index 515271f..54d7e69 100644
--- a/src/lv2.cc
+++ b/src/lv2.cc
@@ -53,6 +53,10 @@
 # define LV2_BUF_SIZE__nominalBlockLength "http://lv2plug.in/ns/ext/buf-size#nominalBlockLength"
 #endif
 
+#ifndef LV2_STATE__StateChanged
+# define LV2_STATE__StateChanged "http://lv2plug.in/ns/ext/state#StateChanged"
+#endif
+
 #ifdef HAVE_LV2_1_8
 #define x_forge_object lv2_atom_forge_object
 #else
@@ -133,6 +137,9 @@ typedef struct {
 	int      rt_policy;
 	int      rt_priority;
 	float    tc64;
+
+	/* next IR file to load, acting as queue */
+	char* next_queued_file;
 } zeroConvolv;
 
 typedef struct {
@@ -322,11 +329,7 @@ instantiate (const LV2_Descriptor*     descriptor,
 	self->patch_Set      = map->map (map->handle, LV2_PATCH__Set);
 	self->patch_property = map->map (map->handle, LV2_PATCH__property);
 	self->patch_value    = map->map (map->handle, LV2_PATCH__value);
-#ifdef LV2_STATE__StateChanged
 	self->state_Changed  = map->map (map->handle, LV2_STATE__StateChanged);
-#else
-	self->state_Changed  = map->map (map->handle, "http://lv2plug.in/ns/ext/state#StateChanged");
-#endif
 	self->zc_chn_delay   = map->map (map->handle, ZC_chn_delay);
 	self->zc_predelay    = map->map (map->handle, ZC_predelay);
 	self->zc_latency     = map->map (map->handle, ZC_latency);
@@ -470,7 +473,9 @@ work_response (LV2_Handle  instance,
 
 	assert (self->clv_online != self->clv_offline || self->clv_online == NULL);
 
-	inform_ui (self, self->pset_dirty);
+	if (self->next_queued_file == NULL)
+		inform_ui (self, self->pset_dirty);
+
 	self->pset_dirty = true;
 
 	uint32_t d = CMD_FREE;
@@ -486,6 +491,8 @@ work (LV2_Handle                  instance,
       const void*                 data)
 {
 	zeroConvolv* self = (zeroConvolv*)instance;
+	const char* fn;
+	size_t fnsize;
 
 	if (size == sizeof (uint32_t)) {
 		switch (*((const uint32_t*)data)) {
@@ -495,7 +502,12 @@ work (LV2_Handle                  instance,
 			case CMD_FREE:
 				pthread_mutex_lock (&self->state_lock);
 				delete self->clv_offline;
-				self->clv_offline = 0;
+				self->clv_offline = NULL;
+				if (self->next_queued_file) {
+					fn = self->next_queued_file;
+					fnsize = strlen (self->next_queued_file);
+					goto loadir;
+				}
 				pthread_mutex_unlock (&self->state_lock);
 				break;
 			default:
@@ -503,32 +515,43 @@ work (LV2_Handle                  instance,
 				break;
 		}
 		return LV2_WORKER_SUCCESS;
+	} else {
+		const LV2_Atom* file_path = (const LV2_Atom*)data;
+		fn = (const char*)(file_path + 1);
+		fnsize = file_path->size;
 	}
 
-	const LV2_Atom* file_path = (const LV2_Atom*)data;
-	const char*     fn        = (const char*)(file_path + 1);
-	std::string     ir_path (fn, file_path->size);
-	lv2_log_note (&self->logger, "ZConvolv request open: ir=%s\n", fn);
-
 	pthread_mutex_lock (&self->state_lock);
+
+loadir:
+	const std::string ir_path (fn, fnsize);
+
 	if (self->clv_offline) {
+		self->next_queued_file = (char*)realloc(self->next_queued_file, fnsize + 1);
+		memcpy (self->next_queued_file, fn, fnsize + 1);
 		pthread_mutex_unlock (&self->state_lock);
-		lv2_log_warning (&self->logger, "ZConvolv Work: offline instance in-use, load ignored.\n");
-		return LV2_WORKER_ERR_UNKNOWN;
+		lv2_log_note (&self->logger, "ZConvolv Work: queueing for later: ir=%s\n", ir_path.c_str());
+		return LV2_WORKER_SUCCESS;
 	}
 
+	lv2_log_note (&self->logger, "ZConvolv opening: ir=%s\n", ir_path.c_str());
+
 	bool ok = false;
 	try {
 		self->clv_offline = new ZeroConvoLV2::Convolver (ir_path, self->rate, self->rt_policy, self->rt_priority, self->chn_cfg);
 		self->clv_offline->reconfigure (self->block_size);
 		if (!(ok = self->clv_offline->ready ())) {
 			delete self->clv_offline;
-			self->clv_offline = 0;
+			self->clv_offline = NULL;
 		}
 	} catch (std::runtime_error& err) {
 		lv2_log_warning (&self->logger, "ZConvolv Convolver: %s.\n", err.what ());
-		self->clv_offline = 0;
+		self->clv_offline = NULL;
 	}
+
+	free (self->next_queued_file);
+	self->next_queued_file = NULL;
+
 	pthread_mutex_unlock (&self->state_lock);
 
 	if (!ok) {
@@ -705,9 +728,22 @@ restore (LV2_Handle                  instance,
 
 	pthread_mutex_lock (&self->state_lock);
 	if (self->clv_offline) {
+		const size_t pathsize = strlen(path);
+		self->next_queued_file = (char*)realloc(self->next_queued_file, pathsize + 1);
+		memcpy (self->next_queued_file, path, pathsize + 1);
 		pthread_mutex_unlock (&self->state_lock);
-		lv2_log_warning (&self->logger, "ZConvolv State: offline instance in-use, state ignored.\n");
-		return LV2_STATE_ERR_UNKNOWN;
+		lv2_log_note (&self->logger, "ZConvolv State: queueing for later: ir=%s\n", path);
+#ifdef LV2_STATE__freePath
+		if (free_path) {
+			free_path->free_path (free_path->handle, path);
+		} else
+#endif
+		{
+#ifndef _WIN32 // https://github.com/drobilla/lilv/issues/14
+			free (path);
+#endif
+		}
+		return LV2_STATE_SUCCESS;
 	}
 
 	bool ok = false;
@@ -716,11 +752,11 @@ restore (LV2_Handle                  instance,
 		self->clv_offline->reconfigure (self->block_size);
 		if (!(ok = self->clv_offline->ready ())) {
 			delete self->clv_offline;
-			self->clv_offline = 0;
+			self->clv_offline = NULL;
 		}
 	} catch (std::runtime_error& err) {
 		lv2_log_warning (&self->logger, "ZConvolv Convolver: %s.\n", err.what ());
-		self->clv_offline = 0;
+		self->clv_offline = NULL;
 	}
 	pthread_mutex_unlock (&self->state_lock);
 
