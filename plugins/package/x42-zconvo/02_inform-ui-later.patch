diff --git a/src/lv2.cc b/src/lv2.cc
index fbf620d..0eb6ad5 100644
--- a/src/lv2.cc
+++ b/src/lv2.cc
@@ -126,6 +126,7 @@ typedef struct {
 	ZeroConvoLV2::Convolver* clv_offline; ///< inactive engine being configured
 
 	bool pset_dirty; // unset before scheduling work for state-restore.
+	int should_inform_ui;
 
 	pthread_mutex_t state_lock;
 	pthread_mutex_t queue_lock;
@@ -317,6 +318,7 @@ instantiate (const LV2_Descriptor*     descriptor,
 	self->dry_target  = 0.f;
 	self->tc64        = 2950.f / rate; // ~20Hz for 90%
 	self->pset_dirty  = true;
+	self->should_inform_ui = 0;
 
 	lv2_atom_forge_init (&self->forge, map);
 
@@ -487,8 +489,6 @@ work_response (LV2_Handle  instance,
 
 	assert (self->clv_online != self->clv_offline || self->clv_online == NULL);
 
-	inform_ui (self, self->pset_dirty);
-
 	self->pset_dirty = true;
 
 	uint32_t d = CMD_FREE;
@@ -590,6 +590,7 @@ work (LV2_Handle                  instance,
 						return load_ir_worker_locked (self, respond, handle, queue_file, unused);
 					} else {
 						pthread_mutex_unlock (&self->state_lock);
+						self->should_inform_ui = 1;
 					}
 				}
 				break;
@@ -1013,6 +1014,10 @@ run_cfg (LV2_Handle instance, uint32_t n_samples)
 	}
 
 	if (self->clv_online) {
+		if (__sync_bool_compare_and_swap(&self->should_inform_ui, 1, 0)) {
+			self->should_inform_ui = 0;
+			inform_ui (self, self->pset_dirty);
+		}
 		run (instance, n_samples);
 		*self->p_latency = self->clv_online->artificial_latency ();
 		return;
