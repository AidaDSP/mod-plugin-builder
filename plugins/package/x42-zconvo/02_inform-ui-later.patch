diff --git a/src/lv2.cc b/src/lv2.cc
index fbf620d..b49353b 100644
--- a/src/lv2.cc
+++ b/src/lv2.cc
@@ -17,6 +17,7 @@
  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  */
 
+#include <atomic>
 #include <cassert>
 #include <cmath>
 #include <cstdlib>
@@ -126,6 +127,7 @@ typedef struct {
 	ZeroConvoLV2::Convolver* clv_offline; ///< inactive engine being configured
 
 	bool pset_dirty; // unset before scheduling work for state-restore.
+	std::atomic<bool> should_inform_ui;
 
 	pthread_mutex_t state_lock;
 	pthread_mutex_t queue_lock;
@@ -317,6 +319,7 @@ instantiate (const LV2_Descriptor*     descriptor,
 	self->dry_target  = 0.f;
 	self->tc64        = 2950.f / rate; // ~20Hz for 90%
 	self->pset_dirty  = true;
+	self->should_inform_ui = false;
 
 	lv2_atom_forge_init (&self->forge, map);
 
@@ -487,8 +490,6 @@ work_response (LV2_Handle  instance,
 
 	assert (self->clv_online != self->clv_offline || self->clv_online == NULL);
 
-	inform_ui (self, self->pset_dirty);
-
 	self->pset_dirty = true;
 
 	uint32_t d = CMD_FREE;
@@ -590,6 +591,7 @@ work (LV2_Handle                  instance,
 						return load_ir_worker_locked (self, respond, handle, queue_file, unused);
 					} else {
 						pthread_mutex_unlock (&self->state_lock);
+						self->should_inform_ui = true;
 					}
 				}
 				break;
@@ -1013,6 +1015,10 @@ run_cfg (LV2_Handle instance, uint32_t n_samples)
 	}
 
 	if (self->clv_online) {
+		bool to_compare = true;
+		if (self->should_inform_ui.compare_exchange_strong(to_compare, false)) {
+			inform_ui (self, self->pset_dirty);
+		}
 		run (instance, n_samples);
 		*self->p_latency = self->clv_online->artificial_latency ();
 		return;
